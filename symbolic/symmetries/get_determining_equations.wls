#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Input:: *)
(*ClearAll["Global`*"];*)
(*Get["C:\\Users\\thivi\\Documents\\GitHub\\koopman-kuramoto\\symbolic\\symmetries\\generate_lexico_tuples.wls"];*)
(**)
(*(* Get the determining equations for a given complex weight matrix, total degree d, number of oscillators N and bounds on the elements of each tuple p *)*)
(*GetDeterminingEquations[A_, d_, N_, bounds_] := Module[{pSubset, pRange, detEqSquare, detEqRectangle,  dc},*)
(*pSubset =GenerateLexicoTuples[d, N, bounds];  (* Indices to non zero coefficients, subset of Z^N in lexicographic order *)*)
(*pRange =GenerateLexicoTuples[d, N, bounds+ {-2,2}];  (* Max range for potentially nontrivial determining equations, subset of Z^N in lexicographic order *)*)
(*c[ell_,p_]:=0/;Not[MemberQ[pSubset,p]];      (*Truncation of the coefficients*)*)
(*dc[ell_,p_] :=      (* Determining equation for a given ell in {1,...,N}, tuple p in a subset of Z^N and complex weight matrix A *)Sum[A[[ell, k]]c[k, p] + Conjugate[A[[ell, k]]]c[k, p - 2UnitVector[N,ell]+ 2UnitVector[N,k]] - 2Conjugate[A[[ell, k]]]c[ell, p - UnitVector[N,ell]+ UnitVector[N,k]] + Sum[(p[[j]]-1+KroneckerDelta[j,k])Conjugate[A[[j, k]]] c[ell,p - UnitVector[N,j]+ UnitVector[N,k]] - (p[[j]]+1-KroneckerDelta[j,k])A[[j, k]] c[ell,p + UnitVector[N,j]- UnitVector[N,k]],{j, 1, N}], {k, 1, N}];*)
(**)
(*(* Get the first set of determining equations regarding the indices for nonzero coefficients in pSubset *)*)
(*detEqSquare = {};*)
(*Do[*)
(*For[i=1, i <= N, i++,*)
(* AppendTo[detEqSquare, dc[i,q]];*)
(*],*)
(*{q, pSubset}];*)
(**)
(*(* Get the second set of determining equations regarding the indices for zero coefficients in Complement[pRange,pSubset]*)*)
(*detEqRectangle = {};*)
(*Do[*)
(*For[i=1, i <= N, i++,*)
(*currentEquation=dc[i,q];*)
(* If[currentEquation=!=0 &&Not[MemberQ[detEqRectangle,currentEquation]],*)
(*AppendTo[ detEqRectangle,currentEquation];];*)
(*],*)
(*{q, Complement[pRange,pSubset]}];*)
(*Return[{detEqSquare, detEqRectangle, pSubset, N}]*)
(*];*)
(**)
(*GetDeterminingMatrices[DetEqS_, DetEqR_, pSubset_,N_]:=Module[{DetMatSquare, DetMatRectangle, DetMat, nonZeroCoefficients},*)
(*	nonZeroCoefficients = GenerateCoefficients[N, pSubset];*)
(*	DetMatSquare=Normal@CoefficientArrays[DetEqS, nonZeroCoefficients][[2]];*)
(*	DetMatRectangle=Normal@CoefficientArrays[DetEqR, nonZeroCoefficients][[2]];*)
(*  DetMat = Join[DetMatSquare,DetMatRectangle,1];*)
(*Return[{DetMatSquare, DetMatRectangle, DetMat, nonZeroCoefficients, pSubset, N}]*)
(*];*)
(**)
(*TotalDegree=1;*)
(*NbNodes=4;*)
(*(* AMat=Array[B,{NbNodes,NbNodes}] *)*)
(*(*AMat={{I,0, 0, 0},*)
(*        {0.3Exp[0.1I],2I,0, 0},*)
(*        {0.1Exp[0.2I],0, I/2,0},*)
(*        {0.5Exp[0.3I],0,0,3I/2}};*)*)
(*AMat={{I/2,0, 0, 0},*)
(*        {1,I/2,0, 0},*)
(*        {1,0, I/2,0},*)
(*        {1,0,0,I/2}};*)
(*pBounds={-1, 2};*)
(*determiningresult=GetDeterminingEquations[AMat,TotalDegree,NbNodes,pBounds];*)
(*DetEqS=determiningresult[[1]];*)
(*DetEqR=determiningresult[[2]];*)
(*pSub=determiningresult[[3]];*)
(*nbNodes=determiningresult[[4]];*)
(**)
(*result=GetDeterminingMatrices[DetEqS,DetEqR,pSub,nbNodes];*)
(*DSquare = result[[1]];*)
(*NRectangle = result[[2]];*)
(*DetMatrix = result[[3]];*)
(*NonZeroCoeffs :=  result[[4]];*)
(*ReImDetMatrix=Map[ReIm,DetMatrix,{2}];*)
(*Export["C:\\Users\\thivi\\Documents\\GitHub\\koopman-kuramoto\\symbolic\\symmetries\\determining_matrices\\ReImDetMatrix_N4_d1_pm1_2.json",ReImDetMatrix,"JSON"];*)
(**)
(*(* Print["Nonzero coefficients in ", NonZeroCoeffs]*)*)
(*Print["# of nonzero coefficients = ", Length[NonZeroCoeffs]]*)
(*Print["square determining matrix M dimension = ", Dimensions[DSquare]]*)
(*Print["rectangular determining matrix N dimension = ", Dimensions[NRectangle]]*)
(*(* Print[DSquare//TraditionalForm] *)*)
(*(* Print[NRectangle//TraditionalForm] *)*)
(*(* Print[DetMatrix//TraditionalForm] *)*)
(**)
(*SingVals := SingularValueList[N[DetMatrix]]  (* DetMatrix for symbolic and N[DetMatrix] for numerical *)*)
(*Print[SingVals]*)
(*Print["There is (are) ", Length[NonZeroCoeffs] - Length[SingVals], " zero singular value(s)."]*)
(**)
(*(* Print[SingularValueDecomposition[N[DetMatrix]]] *)*)



